/* tslint:disable */
/* eslint-disable */
/**
 * Cloud Services for RHEL Compliance API v2
 * UNDER DEVELOPMENT: This version of the API is not fully done and some parts of it might change! This is the API for Cloud Services for RHEL Compliance. You can find out more about Red Hat Cloud Services for RHEL at [https://console.redhat.com/](https://console.redhat.com/)
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AssignRulesRequest
 */
export interface AssignRulesRequest {
    /**
     * 
     * @type {any}
     * @memberof AssignRulesRequest
     */
    'ids'?: any;
}
/**
 * 
 * @export
 * @interface CreatePolicy201Response
 */
export interface CreatePolicy201Response {
    /**
     * 
     * @type {CreatePolicy201ResponseData}
     * @memberof CreatePolicy201Response
     */
    'data'?: CreatePolicy201ResponseData;
}
/**
 * 
 * @export
 * @interface CreatePolicy201ResponseData
 */
export interface CreatePolicy201ResponseData {
    /**
     * 
     * @type {Policy}
     * @memberof CreatePolicy201ResponseData
     */
    'schema'?: Policy;
}
/**
 * 
 * @export
 * @interface Errors
 */
export interface Errors {
    /**
     * 
     * @type {any}
     * @memberof Errors
     */
    'errors': any;
}
/**
 * 
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * Link to first page
     * @type {any}
     * @memberof Links
     */
    'first'?: any;
    /**
     * Link to last page
     * @type {any}
     * @memberof Links
     */
    'last'?: any;
    /**
     * Link to previous page
     * @type {any}
     * @memberof Links
     */
    'previous'?: any;
    /**
     * Link to next page
     * @type {any}
     * @memberof Links
     */
    'next'?: any;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * Total number of items
     * @type {any}
     * @memberof Metadata
     */
    'total'?: any;
    /**
     * Number of items returned per page
     * @type {any}
     * @memberof Metadata
     */
    'limit'?: any;
    /**
     * Offset of the first item of paginated response
     * @type {any}
     * @memberof Metadata
     */
    'offset'?: any;
    /**
     * Attribute and direction the items are sorted by
     * @type {any}
     * @memberof Metadata
     */
    'sort_by'?: any;
    /**
     * Query string used to filter items by their attributes
     * @type {any}
     * @memberof Metadata
     */
    'filter'?: any;
}
/**
 * 
 * @export
 * @interface Policies200Response
 */
export interface Policies200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof Policies200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof Policies200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof Policies200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * 
     * @type {any}
     * @memberof Policy
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof Policy
     */
    'type'?: PolicyTypeEnum;
    /**
     * Short title of the Policy
     * @type {any}
     * @memberof Policy
     */
    'title'?: any;
    /**
     * Longer description of the Policy
     * @type {any}
     * @memberof Policy
     */
    'description'?: any;
    /**
     * The Business Objective associated to the Policy
     * @type {any}
     * @memberof Policy
     */
    'business_objective'?: any;
    /**
     * The percentage above which the Policy meets compliance requirements
     * @type {any}
     * @memberof Policy
     */
    'compliance_threshold': any;
    /**
     * Identifier of the underlying Profile
     * @type {any}
     * @memberof Policy
     */
    'profile_id': any;
    /**
     * Major version of the Operating System that the Policy covers
     * @type {any}
     * @memberof Policy
     */
    'os_major_version'?: any;
    /**
     * Identificator of the Profile
     * @type {any}
     * @memberof Policy
     */
    'ref_id'?: any;
    /**
     * Title of the associated Policy
     * @type {any}
     * @memberof Policy
     */
    'profile_title'?: any;
    /**
     * The number of Systems assigned to this Policy
     * @type {any}
     * @memberof Policy
     */
    'total_system_count'?: any;
}

export const PolicyTypeEnum = {
    Policy: 'policy'
} as const;

export type PolicyTypeEnum = typeof PolicyTypeEnum[keyof typeof PolicyTypeEnum];

/**
 * 
 * @export
 * @interface PolicyUpdate
 */
export interface PolicyUpdate {
    /**
     * Longer description of the Policy
     * @type {any}
     * @memberof PolicyUpdate
     */
    'description'?: any;
    /**
     * The Business Objective associated to the Policy
     * @type {any}
     * @memberof PolicyUpdate
     */
    'business_objective'?: any;
    /**
     * The percentage above which the Policy meets compliance requirements
     * @type {any}
     * @memberof PolicyUpdate
     */
    'compliance_threshold'?: any;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {any}
     * @memberof Profile
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof Profile
     */
    'type'?: ProfileTypeEnum;
    /**
     * Identificator of the Profile
     * @type {any}
     * @memberof Profile
     */
    'ref_id'?: any;
    /**
     * Short title of the Profile
     * @type {any}
     * @memberof Profile
     */
    'title'?: any;
    /**
     * Longer description of the Profile
     * @type {any}
     * @memberof Profile
     */
    'description'?: any;
    /**
     * Pair of keys and values for Value Definition customizations
     * @type {any}
     * @memberof Profile
     */
    'value_overrides'?: any;
}

export const ProfileTypeEnum = {
    Profile: 'profile'
} as const;

export type ProfileTypeEnum = typeof ProfileTypeEnum[keyof typeof ProfileTypeEnum];

/**
 * 
 * @export
 * @interface Profile200Response
 */
export interface Profile200Response {
    /**
     * 
     * @type {Profile200ResponseData}
     * @memberof Profile200Response
     */
    'data'?: Profile200ResponseData;
}
/**
 * 
 * @export
 * @interface Profile200ResponseData
 */
export interface Profile200ResponseData {
    /**
     * 
     * @type {Profile}
     * @memberof Profile200ResponseData
     */
    'schema'?: Profile;
}
/**
 * 
 * @export
 * @interface Profiles200Response
 */
export interface Profiles200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof Profiles200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof Profiles200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof Profiles200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface Report
 */
export interface Report {
    /**
     * 
     * @type {any}
     * @memberof Report
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof Report
     */
    'type'?: ReportTypeEnum;
    /**
     * Short title of the Report
     * @type {any}
     * @memberof Report
     */
    'title'?: any;
    /**
     * The Business Objective associated to the Policy
     * @type {any}
     * @memberof Report
     */
    'business_objective'?: any;
    /**
     * The percentage above which the Policy meets compliance requirements
     * @type {any}
     * @memberof Report
     */
    'compliance_threshold'?: any;
    /**
     * Major version of the Operating System that the Report covers
     * @type {any}
     * @memberof Report
     */
    'os_major_version'?: any;
    /**
     * Identificator of the Profile
     * @type {any}
     * @memberof Report
     */
    'ref_id'?: any;
    /**
     * Title of the associated Profile
     * @type {any}
     * @memberof Report
     */
    'profile_title'?: any;
    /**
     * The number of Systems assigned to this Report
     * @type {any}
     * @memberof Report
     */
    'assigned_system_count'?: any;
    /**
     * The number of compliant Systems in this Report
     * @type {any}
     * @memberof Report
     */
    'compliant_system_count'?: any;
    /**
     * Informs if the user has access to all the Systems under the Report
     * @type {any}
     * @memberof Report
     */
    'all_systems_exposed'?: any;
    /**
     * The number of unsupported Systems in this Report
     * @type {any}
     * @memberof Report
     */
    'unsupported_system_count'?: any;
    /**
     * The number of Systems in this Report that have Test Results available
     * @type {any}
     * @memberof Report
     */
    'reported_system_count'?: any;
}

export const ReportTypeEnum = {
    Report: 'report'
} as const;

export type ReportTypeEnum = typeof ReportTypeEnum[keyof typeof ReportTypeEnum];

/**
 * 
 * @export
 * @interface Report200Response
 */
export interface Report200Response {
    /**
     * 
     * @type {Report200ResponseData}
     * @memberof Report200Response
     */
    'data'?: Report200ResponseData;
}
/**
 * 
 * @export
 * @interface Report200ResponseData
 */
export interface Report200ResponseData {
    /**
     * 
     * @type {Report}
     * @memberof Report200ResponseData
     */
    'schema'?: Report;
}
/**
 * 
 * @export
 * @interface Reports200Response
 */
export interface Reports200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof Reports200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof Reports200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof Reports200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * 
     * @type {any}
     * @memberof Rule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof Rule
     */
    'type'?: RuleTypeEnum;
    /**
     * Identificator of the Rule
     * @type {any}
     * @memberof Rule
     */
    'ref_id'?: any;
    /**
     * Short title of the Rule
     * @type {any}
     * @memberof Rule
     */
    'title'?: any;
    /**
     * Rationale of the Rule
     * @type {any}
     * @memberof Rule
     */
    'rationale'?: any;
    /**
     * Longer description of the Rule
     * @type {any}
     * @memberof Rule
     */
    'description'?: any;
    /**
     * The original sorting precedence of the Rule in the Security Guide
     * @type {any}
     * @memberof Rule
     */
    'precedence'?: any;
    /**
     * The severity of the Rule
     * @type {any}
     * @memberof Rule
     */
    'severity'?: any;
    /**
     * The idenfitier of the remediation associated to this rule, only available under profiles.
     * @type {any}
     * @memberof Rule
     */
    'remediation_issue_id'?: any;
}

export const RuleTypeEnum = {
    Rule: 'rule'
} as const;

export type RuleTypeEnum = typeof RuleTypeEnum[keyof typeof RuleTypeEnum];

/**
 * 
 * @export
 * @interface Rule200Response
 */
export interface Rule200Response {
    /**
     * 
     * @type {Rule200ResponseData}
     * @memberof Rule200Response
     */
    'data'?: Rule200ResponseData;
}
/**
 * 
 * @export
 * @interface Rule200ResponseData
 */
export interface Rule200ResponseData {
    /**
     * 
     * @type {Rule}
     * @memberof Rule200ResponseData
     */
    'schema'?: Rule;
}
/**
 * 
 * @export
 * @interface RuleGroup
 */
export interface RuleGroup {
    /**
     * 
     * @type {any}
     * @memberof RuleGroup
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof RuleGroup
     */
    'type'?: RuleGroupTypeEnum;
    /**
     * Identificator of the Rule Group
     * @type {any}
     * @memberof RuleGroup
     */
    'ref_id'?: any;
    /**
     * Short title of the Rule Group
     * @type {any}
     * @memberof RuleGroup
     */
    'title'?: any;
    /**
     * Rationale of the Rule Group
     * @type {any}
     * @memberof RuleGroup
     */
    'rationale'?: any;
    /**
     * Longer description of the Rule Group
     * @type {any}
     * @memberof RuleGroup
     */
    'description'?: any;
    /**
     * The original sorting precedence of the Rule Group in the Security Guide
     * @type {any}
     * @memberof RuleGroup
     */
    'precedence'?: any;
}

export const RuleGroupTypeEnum = {
    RuleGroup: 'rule_group'
} as const;

export type RuleGroupTypeEnum = typeof RuleGroupTypeEnum[keyof typeof RuleGroupTypeEnum];

/**
 * 
 * @export
 * @interface RuleGroup200Response
 */
export interface RuleGroup200Response {
    /**
     * 
     * @type {RuleGroup200ResponseData}
     * @memberof RuleGroup200Response
     */
    'data'?: RuleGroup200ResponseData;
}
/**
 * 
 * @export
 * @interface RuleGroup200ResponseData
 */
export interface RuleGroup200ResponseData {
    /**
     * 
     * @type {RuleGroup}
     * @memberof RuleGroup200ResponseData
     */
    'schema'?: RuleGroup;
}
/**
 * 
 * @export
 * @interface RuleGroups200Response
 */
export interface RuleGroups200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof RuleGroups200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof RuleGroups200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof RuleGroups200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface Rules200Response
 */
export interface Rules200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof Rules200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof Rules200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof Rules200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface SecurityGuide
 */
export interface SecurityGuide {
    /**
     * 
     * @type {any}
     * @memberof SecurityGuide
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGuide
     */
    'type'?: SecurityGuideTypeEnum;
    /**
     * Identificator of the Security Guide
     * @type {any}
     * @memberof SecurityGuide
     */
    'ref_id'?: any;
    /**
     * Short title of the Security Guide
     * @type {any}
     * @memberof SecurityGuide
     */
    'title'?: any;
    /**
     * Version of the Security Guide
     * @type {any}
     * @memberof SecurityGuide
     */
    'version'?: any;
    /**
     * Longer description of the Security Guide
     * @type {any}
     * @memberof SecurityGuide
     */
    'description'?: any;
    /**
     * Major version of the Operating System that the Security Guide covers
     * @type {any}
     * @memberof SecurityGuide
     */
    'os_major_version'?: any;
}

export const SecurityGuideTypeEnum = {
    SecurityGuide: 'security_guide'
} as const;

export type SecurityGuideTypeEnum = typeof SecurityGuideTypeEnum[keyof typeof SecurityGuideTypeEnum];

/**
 * 
 * @export
 * @interface SecurityGuide200Response
 */
export interface SecurityGuide200Response {
    /**
     * 
     * @type {SecurityGuide200ResponseData}
     * @memberof SecurityGuide200Response
     */
    'data'?: SecurityGuide200ResponseData;
}
/**
 * 
 * @export
 * @interface SecurityGuide200ResponseData
 */
export interface SecurityGuide200ResponseData {
    /**
     * 
     * @type {SecurityGuide}
     * @memberof SecurityGuide200ResponseData
     */
    'schema'?: SecurityGuide;
}
/**
 * 
 * @export
 * @interface SecurityGuides200Response
 */
export interface SecurityGuides200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof SecurityGuides200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof SecurityGuides200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof SecurityGuides200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface SupportedProfile
 */
export interface SupportedProfile {
    /**
     * 
     * @type {any}
     * @memberof SupportedProfile
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SupportedProfile
     */
    'type'?: SupportedProfileTypeEnum;
    /**
     * Identificator of the latest supported Profile
     * @type {any}
     * @memberof SupportedProfile
     */
    'ref_id'?: any;
    /**
     * Short title of the Profile
     * @type {any}
     * @memberof SupportedProfile
     */
    'title'?: any;
    /**
     * UUID of the latest Security Guide supporting this Profile
     * @type {any}
     * @memberof SupportedProfile
     */
    'security_guide_id'?: any;
    /**
     * Version of the latest Security Guide supporting this Profile
     * @type {any}
     * @memberof SupportedProfile
     */
    'security_guide_version'?: any;
    /**
     * Major version of the Operating System that the Profile covers
     * @type {any}
     * @memberof SupportedProfile
     */
    'os_major_version'?: any;
    /**
     * List of the supported Operating System minor versions that the Profile covers
     * @type {any}
     * @memberof SupportedProfile
     */
    'os_minor_versions'?: any;
}

export const SupportedProfileTypeEnum = {
    SupportedProfile: 'supported_profile'
} as const;

export type SupportedProfileTypeEnum = typeof SupportedProfileTypeEnum[keyof typeof SupportedProfileTypeEnum];

/**
 * 
 * @export
 * @interface SupportedProfiles200Response
 */
export interface SupportedProfiles200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof SupportedProfiles200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof SupportedProfiles200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof SupportedProfiles200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface System
 */
export interface System {
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'type'?: SystemTypeEnum;
    /**
     * Display Name of the System
     * @type {any}
     * @memberof System
     */
    'display_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'culled_timestamp'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'stale_timestamp'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'stale_warning_timestamp'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'updated'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'insights_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'tags'?: any;
    /**
     * Major version of the Operating System
     * @type {any}
     * @memberof System
     */
    'os_major_version'?: any;
    /**
     * Minor version of the Operating System
     * @type {any}
     * @memberof System
     */
    'os_minor_version'?: any;
    /**
     * List of Policies assigned to the System, visible only when not listing Systems under a given Policy
     * @type {any}
     * @memberof System
     */
    'policies'?: any;
    /**
     * Whether the system is compliant or not within a given policy, only available under reports.
     * @type {any}
     * @memberof System
     */
    'compliant'?: any;
    /**
     * Number of failed rules within a given policy, only available under reports.
     * @type {any}
     * @memberof System
     */
    'failed_rule_count'?: any;
    /**
     * The date when the system has been reported a scan within a given policy, only available under reports.
     * @type {any}
     * @memberof System
     */
    'last_scanned'?: any;
}

export const SystemTypeEnum = {
    System: 'system'
} as const;

export type SystemTypeEnum = typeof SystemTypeEnum[keyof typeof SystemTypeEnum];

/**
 * 
 * @export
 * @interface System200Response
 */
export interface System200Response {
    /**
     * 
     * @type {System200ResponseData}
     * @memberof System200Response
     */
    'data'?: System200ResponseData;
}
/**
 * 
 * @export
 * @interface System200ResponseData
 */
export interface System200ResponseData {
    /**
     * 
     * @type {System}
     * @memberof System200ResponseData
     */
    'schema'?: System;
}
/**
 * 
 * @export
 * @interface Systems200Response
 */
export interface Systems200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof Systems200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof Systems200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof Systems200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface Tailoring
 */
export interface Tailoring {
    /**
     * 
     * @type {any}
     * @memberof Tailoring
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof Tailoring
     */
    'type'?: TailoringTypeEnum;
    /**
     * Identificator of the Profile from which the Tailoring was cloned
     * @type {any}
     * @memberof Tailoring
     */
    'profile_id'?: any;
    /**
     * Identificator of the Security Guide that contains the parent Profile
     * @type {any}
     * @memberof Tailoring
     */
    'security_guide_id'?: any;
    /**
     * Major version of the Operating System that the Tailoring covers
     * @type {any}
     * @memberof Tailoring
     */
    'os_major_version'?: any;
    /**
     * Minor version of the Operating System that the Tailoring covers
     * @type {any}
     * @memberof Tailoring
     */
    'os_minor_version'?: any;
    /**
     * Pair of keys and values for Value Definition customizations
     * @type {any}
     * @memberof Tailoring
     */
    'value_overrides'?: any;
}

export const TailoringTypeEnum = {
    Tailoring: 'tailoring'
} as const;

export type TailoringTypeEnum = typeof TailoringTypeEnum[keyof typeof TailoringTypeEnum];

/**
 * 
 * @export
 * @interface Tailoring200Response
 */
export interface Tailoring200Response {
    /**
     * 
     * @type {Tailoring200ResponseData}
     * @memberof Tailoring200Response
     */
    'data'?: Tailoring200ResponseData;
}
/**
 * 
 * @export
 * @interface Tailoring200ResponseData
 */
export interface Tailoring200ResponseData {
    /**
     * 
     * @type {Tailoring}
     * @memberof Tailoring200ResponseData
     */
    'schema'?: Tailoring;
}
/**
 * Defines customizations of rules and variables for a set of profiles
 * @export
 * @interface TailoringFile
 */
export interface TailoringFile {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof TailoringFile
     */
    'profiles'?: any;
}
/**
 * 
 * @export
 * @interface Tailorings200Response
 */
export interface Tailorings200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof Tailorings200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof Tailorings200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof Tailorings200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface ValueDefinition
 */
export interface ValueDefinition {
    /**
     * 
     * @type {any}
     * @memberof ValueDefinition
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof ValueDefinition
     */
    'type'?: ValueDefinitionTypeEnum;
    /**
     * Identificator of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'ref_id'?: any;
    /**
     * Short title of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'title'?: any;
    /**
     * Type of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'value_type'?: any;
    /**
     * Longer description of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'description'?: any;
    /**
     * Default value of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'default_value'?: any;
}

export const ValueDefinitionTypeEnum = {
    ValueDefinition: 'value_definition'
} as const;

export type ValueDefinitionTypeEnum = typeof ValueDefinitionTypeEnum[keyof typeof ValueDefinitionTypeEnum];

/**
 * 
 * @export
 * @interface ValueDefinition200Response
 */
export interface ValueDefinition200Response {
    /**
     * 
     * @type {ValueDefinition200ResponseData}
     * @memberof ValueDefinition200Response
     */
    'data'?: ValueDefinition200ResponseData;
}
/**
 * 
 * @export
 * @interface ValueDefinition200ResponseData
 */
export interface ValueDefinition200ResponseData {
    /**
     * 
     * @type {ValueDefinition}
     * @memberof ValueDefinition200ResponseData
     */
    'schema'?: ValueDefinition;
}
/**
 * 
 * @export
 * @interface ValueDefinitions200Response
 */
export interface ValueDefinitions200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof ValueDefinitions200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof ValueDefinitions200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof ValueDefinitions200Response
     */
    'data'?: any;
}

/**
 * ContentApi - axios parameter creator
 * @export
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Profile
         * @summary Request a Profile
         * @param {any} securityGuideId 
         * @param {any} profileId UUID or ref_id
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile: async (securityGuideId: any, profileId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profile', 'securityGuideId', securityGuideId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('profile', 'profileId', profileId)
            const localVarPath = `/security_guides/{security_guide_id}/profiles/{profile_id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Rule assigned to a Profile
         * @summary Request a Rule assigned to a Profile
         * @param {any} securityGuideId 
         * @param {any} profileId 
         * @param {any} ruleId UUID or ref_id
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRule: async (securityGuideId: any, profileId: any, ruleId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profileRule', 'securityGuideId', securityGuideId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('profileRule', 'profileId', profileId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('profileRule', 'ruleId', ruleId)
            const localVarPath = `/security_guides/{security_guide_id}/profiles/{profile_id}/rules/{rule_id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Rules assigned to a Profile
         * @summary Request Rules assigned to a Profile
         * @param {any} securityGuideId 
         * @param {any} profileId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRules: async (securityGuideId: any, profileId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profileRules', 'securityGuideId', securityGuideId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('profileRules', 'profileId', profileId)
            const localVarPath = `/security_guides/{security_guide_id}/profiles/{profile_id}/rules`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Profiles
         * @summary Request Profiles
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profiles: async (securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profiles', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/profiles`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Rule
         * @summary Request a Rule
         * @param {any} securityGuideId 
         * @param {any} ruleId UUID or ref_id
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rule: async (securityGuideId: any, ruleId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('rule', 'securityGuideId', securityGuideId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('rule', 'ruleId', ruleId)
            const localVarPath = `/security_guides/{security_guide_id}/rules/{rule_id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Rule Group
         * @summary Request a Rule Group
         * @param {any} securityGuideId 
         * @param {any} ruleGroupId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroup: async (securityGuideId: any, ruleGroupId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('ruleGroup', 'securityGuideId', securityGuideId)
            // verify required parameter 'ruleGroupId' is not null or undefined
            assertParamExists('ruleGroup', 'ruleGroupId', ruleGroupId)
            const localVarPath = `/security_guides/{security_guide_id}/rule_groups/{rule_group_id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"rule_group_id"}}`, encodeURIComponent(String(ruleGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Rule Groups
         * @summary Request Rule Groups
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroups: async (securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('ruleGroups', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/rule_groups`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Rules assigned
         * @summary Request Rules
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rules: async (securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('rules', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/rules`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Security Guide
         * @summary Request a Security Guide
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuide: async (securityGuideId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('securityGuide', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Rule Tree of a Security Guide
         * @summary Request the Rule Tree of a Security Guide
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuideRuleTree: async (securityGuideId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('securityGuideRuleTree', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/rule_tree`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Security Guides
         * @summary Request Security Guides
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuides: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/security_guides`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Supported Profiles
         * @summary Request Supported Profiles
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportedProfiles: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/security_guides/supported_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Value Definition
         * @summary Request a Value Definition
         * @param {any} securityGuideId 
         * @param {any} valueDefinitionId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinition: async (securityGuideId: any, valueDefinitionId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('valueDefinition', 'securityGuideId', securityGuideId)
            // verify required parameter 'valueDefinitionId' is not null or undefined
            assertParamExists('valueDefinition', 'valueDefinitionId', valueDefinitionId)
            const localVarPath = `/security_guides/{security_guide_id}/value_definitions/{value_definition_id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"value_definition_id"}}`, encodeURIComponent(String(valueDefinitionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Value Definitions
         * @summary Request Value Definitions
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinitions: async (securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('valueDefinitions', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/value_definitions`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Profile
         * @summary Request a Profile
         * @param {any} securityGuideId 
         * @param {any} profileId UUID or ref_id
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profile(securityGuideId: any, profileId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profile(securityGuideId, profileId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Rule assigned to a Profile
         * @summary Request a Rule assigned to a Profile
         * @param {any} securityGuideId 
         * @param {any} profileId 
         * @param {any} ruleId UUID or ref_id
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileRule(securityGuideId: any, profileId: any, ruleId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileRule(securityGuideId, profileId, ruleId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Rules assigned to a Profile
         * @summary Request Rules assigned to a Profile
         * @param {any} securityGuideId 
         * @param {any} profileId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileRules(securityGuideId: any, profileId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileRules(securityGuideId, profileId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Profiles
         * @summary Request Profiles
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profiles(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profiles(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Rule
         * @summary Request a Rule
         * @param {any} securityGuideId 
         * @param {any} ruleId UUID or ref_id
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rule(securityGuideId: any, ruleId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rule(securityGuideId, ruleId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Rule Group
         * @summary Request a Rule Group
         * @param {any} securityGuideId 
         * @param {any} ruleGroupId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleGroup(securityGuideId: any, ruleGroupId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleGroup(securityGuideId, ruleGroupId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Rule Groups
         * @summary Request Rule Groups
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleGroups(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleGroups(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Rules assigned
         * @summary Request Rules
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rules(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rules(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Security Guide
         * @summary Request a Security Guide
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGuide(securityGuideId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGuide200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGuide(securityGuideId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Rule Tree of a Security Guide
         * @summary Request the Rule Tree of a Security Guide
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGuideRuleTree(securityGuideId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGuideRuleTree(securityGuideId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Security Guides
         * @summary Request Security Guides
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGuides(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGuides200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGuides(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Supported Profiles
         * @summary Request Supported Profiles
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportedProfiles(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportedProfiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportedProfiles(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Value Definition
         * @summary Request a Value Definition
         * @param {any} securityGuideId 
         * @param {any} valueDefinitionId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async valueDefinition(securityGuideId: any, valueDefinitionId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueDefinition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.valueDefinition(securityGuideId, valueDefinitionId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Value Definitions
         * @summary Request Value Definitions
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async valueDefinitions(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueDefinitions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.valueDefinitions(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentApiFp(configuration)
    return {
        /**
         * Returns a Profile
         * @summary Request a Profile
         * @param {ContentApiProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile(requestParameters: ContentApiProfileRequest, options?: AxiosRequestConfig): AxiosPromise<Profile200Response> {
            return localVarFp.profile(requestParameters.securityGuideId, requestParameters.profileId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Rule assigned to a Profile
         * @summary Request a Rule assigned to a Profile
         * @param {ContentApiProfileRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRule(requestParameters: ContentApiProfileRuleRequest, options?: AxiosRequestConfig): AxiosPromise<Rule200Response> {
            return localVarFp.profileRule(requestParameters.securityGuideId, requestParameters.profileId, requestParameters.ruleId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Rules assigned to a Profile
         * @summary Request Rules assigned to a Profile
         * @param {ContentApiProfileRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRules(requestParameters: ContentApiProfileRulesRequest, options?: AxiosRequestConfig): AxiosPromise<Rules200Response> {
            return localVarFp.profileRules(requestParameters.securityGuideId, requestParameters.profileId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Profiles
         * @summary Request Profiles
         * @param {ContentApiProfilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profiles(requestParameters: ContentApiProfilesRequest, options?: AxiosRequestConfig): AxiosPromise<Profiles200Response> {
            return localVarFp.profiles(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Rule
         * @summary Request a Rule
         * @param {ContentApiRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rule(requestParameters: ContentApiRuleRequest, options?: AxiosRequestConfig): AxiosPromise<Rule200Response> {
            return localVarFp.rule(requestParameters.securityGuideId, requestParameters.ruleId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Rule Group
         * @summary Request a Rule Group
         * @param {ContentApiRuleGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroup(requestParameters: ContentApiRuleGroupRequest, options?: AxiosRequestConfig): AxiosPromise<RuleGroup200Response> {
            return localVarFp.ruleGroup(requestParameters.securityGuideId, requestParameters.ruleGroupId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Rule Groups
         * @summary Request Rule Groups
         * @param {ContentApiRuleGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroups(requestParameters: ContentApiRuleGroupsRequest, options?: AxiosRequestConfig): AxiosPromise<RuleGroups200Response> {
            return localVarFp.ruleGroups(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Rules assigned
         * @summary Request Rules
         * @param {ContentApiRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rules(requestParameters: ContentApiRulesRequest, options?: AxiosRequestConfig): AxiosPromise<Rules200Response> {
            return localVarFp.rules(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Security Guide
         * @summary Request a Security Guide
         * @param {ContentApiSecurityGuideRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuide(requestParameters: ContentApiSecurityGuideRequest, options?: AxiosRequestConfig): AxiosPromise<SecurityGuide200Response> {
            return localVarFp.securityGuide(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Rule Tree of a Security Guide
         * @summary Request the Rule Tree of a Security Guide
         * @param {ContentApiSecurityGuideRuleTreeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuideRuleTree(requestParameters: ContentApiSecurityGuideRuleTreeRequest, options?: AxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.securityGuideRuleTree(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Security Guides
         * @summary Request Security Guides
         * @param {ContentApiSecurityGuidesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuides(requestParameters: ContentApiSecurityGuidesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<SecurityGuides200Response> {
            return localVarFp.securityGuides(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Supported Profiles
         * @summary Request Supported Profiles
         * @param {ContentApiSupportedProfilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportedProfiles(requestParameters: ContentApiSupportedProfilesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<SupportedProfiles200Response> {
            return localVarFp.supportedProfiles(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Value Definition
         * @summary Request a Value Definition
         * @param {ContentApiValueDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinition(requestParameters: ContentApiValueDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<ValueDefinition200Response> {
            return localVarFp.valueDefinition(requestParameters.securityGuideId, requestParameters.valueDefinitionId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Value Definitions
         * @summary Request Value Definitions
         * @param {ContentApiValueDefinitionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinitions(requestParameters: ContentApiValueDefinitionsRequest, options?: AxiosRequestConfig): AxiosPromise<ValueDefinitions200Response> {
            return localVarFp.valueDefinitions(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for profile operation in ContentApi.
 * @export
 * @interface ContentApiProfileRequest
 */
export interface ContentApiProfileRequest {
    /**
     * 
     * @type {any}
     * @memberof ContentApiProfile
     */
    readonly securityGuideId: any

    /**
     * UUID or ref_id
     * @type {any}
     * @memberof ContentApiProfile
     */
    readonly profileId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiProfile
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for profileRule operation in ContentApi.
 * @export
 * @interface ContentApiProfileRuleRequest
 */
export interface ContentApiProfileRuleRequest {
    /**
     * 
     * @type {any}
     * @memberof ContentApiProfileRule
     */
    readonly securityGuideId: any

    /**
     * 
     * @type {any}
     * @memberof ContentApiProfileRule
     */
    readonly profileId: any

    /**
     * UUID or ref_id
     * @type {any}
     * @memberof ContentApiProfileRule
     */
    readonly ruleId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiProfileRule
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for profileRules operation in ContentApi.
 * @export
 * @interface ContentApiProfileRulesRequest
 */
export interface ContentApiProfileRulesRequest {
    /**
     * 
     * @type {any}
     * @memberof ContentApiProfileRules
     */
    readonly securityGuideId: any

    /**
     * 
     * @type {any}
     * @memberof ContentApiProfileRules
     */
    readonly profileId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiProfileRules
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ContentApiProfileRules
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ContentApiProfileRules
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ContentApiProfileRules
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ContentApiProfileRules
     */
    readonly filter?: any
}

/**
 * Request parameters for profiles operation in ContentApi.
 * @export
 * @interface ContentApiProfilesRequest
 */
export interface ContentApiProfilesRequest {
    /**
     * 
     * @type {any}
     * @memberof ContentApiProfiles
     */
    readonly securityGuideId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiProfiles
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ContentApiProfiles
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ContentApiProfiles
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ContentApiProfiles
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ContentApiProfiles
     */
    readonly filter?: any
}

/**
 * Request parameters for rule operation in ContentApi.
 * @export
 * @interface ContentApiRuleRequest
 */
export interface ContentApiRuleRequest {
    /**
     * 
     * @type {any}
     * @memberof ContentApiRule
     */
    readonly securityGuideId: any

    /**
     * UUID or ref_id
     * @type {any}
     * @memberof ContentApiRule
     */
    readonly ruleId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiRule
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for ruleGroup operation in ContentApi.
 * @export
 * @interface ContentApiRuleGroupRequest
 */
export interface ContentApiRuleGroupRequest {
    /**
     * 
     * @type {any}
     * @memberof ContentApiRuleGroup
     */
    readonly securityGuideId: any

    /**
     * 
     * @type {any}
     * @memberof ContentApiRuleGroup
     */
    readonly ruleGroupId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiRuleGroup
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for ruleGroups operation in ContentApi.
 * @export
 * @interface ContentApiRuleGroupsRequest
 */
export interface ContentApiRuleGroupsRequest {
    /**
     * 
     * @type {any}
     * @memberof ContentApiRuleGroups
     */
    readonly securityGuideId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiRuleGroups
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ContentApiRuleGroups
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ContentApiRuleGroups
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ContentApiRuleGroups
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ContentApiRuleGroups
     */
    readonly filter?: any
}

/**
 * Request parameters for rules operation in ContentApi.
 * @export
 * @interface ContentApiRulesRequest
 */
export interface ContentApiRulesRequest {
    /**
     * 
     * @type {any}
     * @memberof ContentApiRules
     */
    readonly securityGuideId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiRules
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ContentApiRules
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ContentApiRules
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ContentApiRules
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ContentApiRules
     */
    readonly filter?: any
}

/**
 * Request parameters for securityGuide operation in ContentApi.
 * @export
 * @interface ContentApiSecurityGuideRequest
 */
export interface ContentApiSecurityGuideRequest {
    /**
     * 
     * @type {any}
     * @memberof ContentApiSecurityGuide
     */
    readonly securityGuideId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiSecurityGuide
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for securityGuideRuleTree operation in ContentApi.
 * @export
 * @interface ContentApiSecurityGuideRuleTreeRequest
 */
export interface ContentApiSecurityGuideRuleTreeRequest {
    /**
     * 
     * @type {any}
     * @memberof ContentApiSecurityGuideRuleTree
     */
    readonly securityGuideId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiSecurityGuideRuleTree
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for securityGuides operation in ContentApi.
 * @export
 * @interface ContentApiSecurityGuidesRequest
 */
export interface ContentApiSecurityGuidesRequest {
    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiSecurityGuides
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ContentApiSecurityGuides
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ContentApiSecurityGuides
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ContentApiSecurityGuides
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ContentApiSecurityGuides
     */
    readonly filter?: any
}

/**
 * Request parameters for supportedProfiles operation in ContentApi.
 * @export
 * @interface ContentApiSupportedProfilesRequest
 */
export interface ContentApiSupportedProfilesRequest {
    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiSupportedProfiles
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ContentApiSupportedProfiles
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ContentApiSupportedProfiles
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ContentApiSupportedProfiles
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ContentApiSupportedProfiles
     */
    readonly filter?: any
}

/**
 * Request parameters for valueDefinition operation in ContentApi.
 * @export
 * @interface ContentApiValueDefinitionRequest
 */
export interface ContentApiValueDefinitionRequest {
    /**
     * 
     * @type {any}
     * @memberof ContentApiValueDefinition
     */
    readonly securityGuideId: any

    /**
     * 
     * @type {any}
     * @memberof ContentApiValueDefinition
     */
    readonly valueDefinitionId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiValueDefinition
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for valueDefinitions operation in ContentApi.
 * @export
 * @interface ContentApiValueDefinitionsRequest
 */
export interface ContentApiValueDefinitionsRequest {
    /**
     * 
     * @type {any}
     * @memberof ContentApiValueDefinitions
     */
    readonly securityGuideId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ContentApiValueDefinitions
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ContentApiValueDefinitions
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ContentApiValueDefinitions
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ContentApiValueDefinitions
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ContentApiValueDefinitions
     */
    readonly filter?: any
}

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
    /**
     * Returns a Profile
     * @summary Request a Profile
     * @param {ContentApiProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public profile(requestParameters: ContentApiProfileRequest, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).profile(requestParameters.securityGuideId, requestParameters.profileId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Rule assigned to a Profile
     * @summary Request a Rule assigned to a Profile
     * @param {ContentApiProfileRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public profileRule(requestParameters: ContentApiProfileRuleRequest, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).profileRule(requestParameters.securityGuideId, requestParameters.profileId, requestParameters.ruleId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Rules assigned to a Profile
     * @summary Request Rules assigned to a Profile
     * @param {ContentApiProfileRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public profileRules(requestParameters: ContentApiProfileRulesRequest, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).profileRules(requestParameters.securityGuideId, requestParameters.profileId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Profiles
     * @summary Request Profiles
     * @param {ContentApiProfilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public profiles(requestParameters: ContentApiProfilesRequest, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).profiles(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Rule
     * @summary Request a Rule
     * @param {ContentApiRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public rule(requestParameters: ContentApiRuleRequest, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).rule(requestParameters.securityGuideId, requestParameters.ruleId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Rule Group
     * @summary Request a Rule Group
     * @param {ContentApiRuleGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public ruleGroup(requestParameters: ContentApiRuleGroupRequest, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).ruleGroup(requestParameters.securityGuideId, requestParameters.ruleGroupId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Rule Groups
     * @summary Request Rule Groups
     * @param {ContentApiRuleGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public ruleGroups(requestParameters: ContentApiRuleGroupsRequest, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).ruleGroups(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Rules assigned
     * @summary Request Rules
     * @param {ContentApiRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public rules(requestParameters: ContentApiRulesRequest, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).rules(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Security Guide
     * @summary Request a Security Guide
     * @param {ContentApiSecurityGuideRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public securityGuide(requestParameters: ContentApiSecurityGuideRequest, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).securityGuide(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Rule Tree of a Security Guide
     * @summary Request the Rule Tree of a Security Guide
     * @param {ContentApiSecurityGuideRuleTreeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public securityGuideRuleTree(requestParameters: ContentApiSecurityGuideRuleTreeRequest, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).securityGuideRuleTree(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Security Guides
     * @summary Request Security Guides
     * @param {ContentApiSecurityGuidesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public securityGuides(requestParameters: ContentApiSecurityGuidesRequest = {}, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).securityGuides(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Supported Profiles
     * @summary Request Supported Profiles
     * @param {ContentApiSupportedProfilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public supportedProfiles(requestParameters: ContentApiSupportedProfilesRequest = {}, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).supportedProfiles(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Value Definition
     * @summary Request a Value Definition
     * @param {ContentApiValueDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public valueDefinition(requestParameters: ContentApiValueDefinitionRequest, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).valueDefinition(requestParameters.securityGuideId, requestParameters.valueDefinitionId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Value Definitions
     * @summary Request Value Definitions
     * @param {ContentApiValueDefinitionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public valueDefinitions(requestParameters: ContentApiValueDefinitionsRequest, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).valueDefinitions(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a Rule to a Tailoring
         * @summary Assign a Rule to a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} ruleId UUID or ref_id
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRule: async (policyId: any, tailoringId: any, ruleId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignRule', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('assignRule', 'tailoringId', tailoringId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('assignRule', 'ruleId', ruleId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules/{rule_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Rules to a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {AssignRulesRequest} [assignRulesRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignRules: async (policyId: any, tailoringId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignRules', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('assignRules', 'tailoringId', tailoringId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns a System to a Policy
         * @summary Assign a System to a Policy
         * @param {any} systemId 
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignSystem: async (systemId: any, policyId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('assignSystem', 'systemId', systemId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignSystem', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems/{system_id}`
                .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)))
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Systems to a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {AssignRulesRequest} [assignRulesRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignSystems: async (policyId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignSystems', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Policy with the provided attributes
         * @summary Create a Policy
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {Policy} [policy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy: async (xRHIDENTITY?: any, policy?: Policy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Policy
         * @summary Delete a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy: async (policyId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('deletePolicy', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Policies
         * @summary Request Policies
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policies: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Policy
         * @summary Request a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policy: async (policyId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policy', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Systems assigned to a Policy
         * @summary Request Systems assigned to a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policySystems: async (policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policySystems', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Tailoring
         * @summary Request a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId UUID or OS minor version number
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoring: async (policyId: any, tailoringId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailoring', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('tailoring', 'tailoringId', tailoringId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Tailoring File
         * @summary Request a Tailoring file
         * @param {any} policyId 
         * @param {any} tailoringId UUID or OS minor version number
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringFile: async (policyId: any, tailoringId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailoringFile', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('tailoringFile', 'tailoringId', tailoringId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/tailoring_file.json`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Rules assigned to a Tailoring
         * @summary Request Rules assigned to a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringRules: async (policyId: any, tailoringId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailoringRules', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('tailoringRules', 'tailoringId', tailoringId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Tailorings
         * @summary Request Tailorings
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailorings: async (policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailorings', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/tailorings`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unassigns a Rule from a Tailoring
         * @summary Unassign a Rule from a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} ruleId UUID or ref_id
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignRule: async (policyId: any, tailoringId: any, ruleId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('unassignRule', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('unassignRule', 'tailoringId', tailoringId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('unassignRule', 'ruleId', ruleId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules/{rule_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)))
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unassigns a System from a Policy
         * @summary Unassign a System from a Policy
         * @param {any} systemId 
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignSystem: async (systemId: any, policyId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('unassignSystem', 'systemId', systemId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('unassignSystem', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems/{system_id}`
                .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)))
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Policy with the provided attributes
         * @summary Update a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {PolicyUpdate} [policyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy: async (policyId: any, xRHIDENTITY?: any, policyUpdate?: PolicyUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('updatePolicy', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Tailoring with the provided value_overrides
         * @summary Update a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId UUID or OS minor version number
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {Tailoring} [tailoring] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTailoring: async (policyId: any, tailoringId: any, xRHIDENTITY?: any, tailoring?: Tailoring, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('updateTailoring', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('updateTailoring', 'tailoringId', tailoringId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tailoring, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Assigns a Rule to a Tailoring
         * @summary Assign a Rule to a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} ruleId UUID or ref_id
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignRule(policyId: any, tailoringId: any, ruleId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignRule(policyId, tailoringId, ruleId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Rules to a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {AssignRulesRequest} [assignRulesRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async assignRules(policyId: any, tailoringId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignRules(policyId, tailoringId, xRHIDENTITY, assignRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Assigns a System to a Policy
         * @summary Assign a System to a Policy
         * @param {any} systemId 
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignSystem(systemId: any, policyId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignSystem(systemId, policyId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Systems to a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {AssignRulesRequest} [assignRulesRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async assignSystems(policyId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignSystems(policyId, xRHIDENTITY, assignRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Policy with the provided attributes
         * @summary Create a Policy
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {Policy} [policy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicy(xRHIDENTITY?: any, policy?: Policy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicy(xRHIDENTITY, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a Policy
         * @summary Delete a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicy(policyId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicy(policyId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Policies
         * @summary Request Policies
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policies(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policies(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Policy
         * @summary Request a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policy(policyId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policy(policyId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Systems assigned to a Policy
         * @summary Request Systems assigned to a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policySystems(policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policySystems(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Tailoring
         * @summary Request a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId UUID or OS minor version number
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailoring(policyId: any, tailoringId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tailoring200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailoring(policyId, tailoringId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Tailoring File
         * @summary Request a Tailoring file
         * @param {any} policyId 
         * @param {any} tailoringId UUID or OS minor version number
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailoringFile(policyId: any, tailoringId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TailoringFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailoringFile(policyId, tailoringId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Rules assigned to a Tailoring
         * @summary Request Rules assigned to a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailoringRules(policyId: any, tailoringId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailoringRules(policyId, tailoringId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Tailorings
         * @summary Request Tailorings
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailorings(policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tailorings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailorings(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unassigns a Rule from a Tailoring
         * @summary Unassign a Rule from a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} ruleId UUID or ref_id
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignRule(policyId: any, tailoringId: any, ruleId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRule(policyId, tailoringId, ruleId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unassigns a System from a Policy
         * @summary Unassign a System from a Policy
         * @param {any} systemId 
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignSystem(systemId: any, policyId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignSystem(systemId, policyId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Policy with the provided attributes
         * @summary Update a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {PolicyUpdate} [policyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicy(policyId: any, xRHIDENTITY?: any, policyUpdate?: PolicyUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicy(policyId, xRHIDENTITY, policyUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Tailoring with the provided value_overrides
         * @summary Update a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId UUID or OS minor version number
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {Tailoring} [tailoring] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTailoring(policyId: any, tailoringId: any, xRHIDENTITY?: any, tailoring?: Tailoring, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tailoring200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTailoring(policyId, tailoringId, xRHIDENTITY, tailoring, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * Assigns a Rule to a Tailoring
         * @summary Assign a Rule to a Tailoring
         * @param {PoliciesApiAssignRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRule(requestParameters: PoliciesApiAssignRuleRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.assignRule(requestParameters.policyId, requestParameters.tailoringId, requestParameters.ruleId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Rules to a Tailoring
         * @param {PoliciesApiAssignRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignRules(requestParameters: PoliciesApiAssignRulesRequest, options?: AxiosRequestConfig): AxiosPromise<Rules200Response> {
            return localVarFp.assignRules(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, requestParameters.assignRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Assigns a System to a Policy
         * @summary Assign a System to a Policy
         * @param {PoliciesApiAssignSystemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignSystem(requestParameters: PoliciesApiAssignSystemRequest, options?: AxiosRequestConfig): AxiosPromise<System200Response> {
            return localVarFp.assignSystem(requestParameters.systemId, requestParameters.policyId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Systems to a Policy
         * @param {PoliciesApiAssignSystemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignSystems(requestParameters: PoliciesApiAssignSystemsRequest, options?: AxiosRequestConfig): AxiosPromise<Systems200Response> {
            return localVarFp.assignSystems(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.assignRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Policy with the provided attributes
         * @summary Create a Policy
         * @param {PoliciesApiCreatePolicyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(requestParameters: PoliciesApiCreatePolicyRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.createPolicy(requestParameters.xRHIDENTITY, requestParameters.policy, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Policy
         * @summary Delete a Policy
         * @param {PoliciesApiDeletePolicyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(requestParameters: PoliciesApiDeletePolicyRequest, options?: AxiosRequestConfig): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.deletePolicy(requestParameters.policyId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Policies
         * @summary Request Policies
         * @param {PoliciesApiPoliciesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policies(requestParameters: PoliciesApiPoliciesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Policies200Response> {
            return localVarFp.policies(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Policy
         * @summary Request a Policy
         * @param {PoliciesApiPolicyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policy(requestParameters: PoliciesApiPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.policy(requestParameters.policyId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Systems assigned to a Policy
         * @summary Request Systems assigned to a Policy
         * @param {PoliciesApiPolicySystemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policySystems(requestParameters: PoliciesApiPolicySystemsRequest, options?: AxiosRequestConfig): AxiosPromise<Systems200Response> {
            return localVarFp.policySystems(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Tailoring
         * @summary Request a Tailoring
         * @param {PoliciesApiTailoringRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoring(requestParameters: PoliciesApiTailoringRequest, options?: AxiosRequestConfig): AxiosPromise<Tailoring200Response> {
            return localVarFp.tailoring(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Tailoring File
         * @summary Request a Tailoring file
         * @param {PoliciesApiTailoringFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringFile(requestParameters: PoliciesApiTailoringFileRequest, options?: AxiosRequestConfig): AxiosPromise<TailoringFile> {
            return localVarFp.tailoringFile(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Rules assigned to a Tailoring
         * @summary Request Rules assigned to a Tailoring
         * @param {PoliciesApiTailoringRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringRules(requestParameters: PoliciesApiTailoringRulesRequest, options?: AxiosRequestConfig): AxiosPromise<Rules200Response> {
            return localVarFp.tailoringRules(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Tailorings
         * @summary Request Tailorings
         * @param {PoliciesApiTailoringsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailorings(requestParameters: PoliciesApiTailoringsRequest, options?: AxiosRequestConfig): AxiosPromise<Tailorings200Response> {
            return localVarFp.tailorings(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Unassigns a Rule from a Tailoring
         * @summary Unassign a Rule from a Tailoring
         * @param {PoliciesApiUnassignRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignRule(requestParameters: PoliciesApiUnassignRuleRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unassignRule(requestParameters.policyId, requestParameters.tailoringId, requestParameters.ruleId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Unassigns a System from a Policy
         * @summary Unassign a System from a Policy
         * @param {PoliciesApiUnassignSystemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignSystem(requestParameters: PoliciesApiUnassignSystemRequest, options?: AxiosRequestConfig): AxiosPromise<System200Response> {
            return localVarFp.unassignSystem(requestParameters.systemId, requestParameters.policyId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Policy with the provided attributes
         * @summary Update a Policy
         * @param {PoliciesApiUpdatePolicyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(requestParameters: PoliciesApiUpdatePolicyRequest, options?: AxiosRequestConfig): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.updatePolicy(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.policyUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Tailoring with the provided value_overrides
         * @summary Update a Tailoring
         * @param {PoliciesApiUpdateTailoringRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTailoring(requestParameters: PoliciesApiUpdateTailoringRequest, options?: AxiosRequestConfig): AxiosPromise<Tailoring200Response> {
            return localVarFp.updateTailoring(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, requestParameters.tailoring, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for assignRule operation in PoliciesApi.
 * @export
 * @interface PoliciesApiAssignRuleRequest
 */
export interface PoliciesApiAssignRuleRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiAssignRule
     */
    readonly policyId: any

    /**
     * 
     * @type {any}
     * @memberof PoliciesApiAssignRule
     */
    readonly tailoringId: any

    /**
     * UUID or ref_id
     * @type {any}
     * @memberof PoliciesApiAssignRule
     */
    readonly ruleId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiAssignRule
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for assignRules operation in PoliciesApi.
 * @export
 * @interface PoliciesApiAssignRulesRequest
 */
export interface PoliciesApiAssignRulesRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiAssignRules
     */
    readonly policyId: any

    /**
     * 
     * @type {any}
     * @memberof PoliciesApiAssignRules
     */
    readonly tailoringId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiAssignRules
     */
    readonly xRHIDENTITY?: any

    /**
     * 
     * @type {AssignRulesRequest}
     * @memberof PoliciesApiAssignRules
     */
    readonly assignRulesRequest?: AssignRulesRequest
}

/**
 * Request parameters for assignSystem operation in PoliciesApi.
 * @export
 * @interface PoliciesApiAssignSystemRequest
 */
export interface PoliciesApiAssignSystemRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiAssignSystem
     */
    readonly systemId: any

    /**
     * 
     * @type {any}
     * @memberof PoliciesApiAssignSystem
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiAssignSystem
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for assignSystems operation in PoliciesApi.
 * @export
 * @interface PoliciesApiAssignSystemsRequest
 */
export interface PoliciesApiAssignSystemsRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiAssignSystems
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiAssignSystems
     */
    readonly xRHIDENTITY?: any

    /**
     * 
     * @type {AssignRulesRequest}
     * @memberof PoliciesApiAssignSystems
     */
    readonly assignRulesRequest?: AssignRulesRequest
}

/**
 * Request parameters for createPolicy operation in PoliciesApi.
 * @export
 * @interface PoliciesApiCreatePolicyRequest
 */
export interface PoliciesApiCreatePolicyRequest {
    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiCreatePolicy
     */
    readonly xRHIDENTITY?: any

    /**
     * 
     * @type {Policy}
     * @memberof PoliciesApiCreatePolicy
     */
    readonly policy?: Policy
}

/**
 * Request parameters for deletePolicy operation in PoliciesApi.
 * @export
 * @interface PoliciesApiDeletePolicyRequest
 */
export interface PoliciesApiDeletePolicyRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiDeletePolicy
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiDeletePolicy
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for policies operation in PoliciesApi.
 * @export
 * @interface PoliciesApiPoliciesRequest
 */
export interface PoliciesApiPoliciesRequest {
    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiPolicies
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof PoliciesApiPolicies
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof PoliciesApiPolicies
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof PoliciesApiPolicies
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof PoliciesApiPolicies
     */
    readonly filter?: any
}

/**
 * Request parameters for policy operation in PoliciesApi.
 * @export
 * @interface PoliciesApiPolicyRequest
 */
export interface PoliciesApiPolicyRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiPolicy
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiPolicy
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for policySystems operation in PoliciesApi.
 * @export
 * @interface PoliciesApiPolicySystemsRequest
 */
export interface PoliciesApiPolicySystemsRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiPolicySystems
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiPolicySystems
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof PoliciesApiPolicySystems
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof PoliciesApiPolicySystems
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof PoliciesApiPolicySystems
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof PoliciesApiPolicySystems
     */
    readonly filter?: any
}

/**
 * Request parameters for tailoring operation in PoliciesApi.
 * @export
 * @interface PoliciesApiTailoringRequest
 */
export interface PoliciesApiTailoringRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiTailoring
     */
    readonly policyId: any

    /**
     * UUID or OS minor version number
     * @type {any}
     * @memberof PoliciesApiTailoring
     */
    readonly tailoringId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiTailoring
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for tailoringFile operation in PoliciesApi.
 * @export
 * @interface PoliciesApiTailoringFileRequest
 */
export interface PoliciesApiTailoringFileRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiTailoringFile
     */
    readonly policyId: any

    /**
     * UUID or OS minor version number
     * @type {any}
     * @memberof PoliciesApiTailoringFile
     */
    readonly tailoringId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiTailoringFile
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for tailoringRules operation in PoliciesApi.
 * @export
 * @interface PoliciesApiTailoringRulesRequest
 */
export interface PoliciesApiTailoringRulesRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiTailoringRules
     */
    readonly policyId: any

    /**
     * 
     * @type {any}
     * @memberof PoliciesApiTailoringRules
     */
    readonly tailoringId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiTailoringRules
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof PoliciesApiTailoringRules
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof PoliciesApiTailoringRules
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof PoliciesApiTailoringRules
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof PoliciesApiTailoringRules
     */
    readonly filter?: any
}

/**
 * Request parameters for tailorings operation in PoliciesApi.
 * @export
 * @interface PoliciesApiTailoringsRequest
 */
export interface PoliciesApiTailoringsRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiTailorings
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiTailorings
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof PoliciesApiTailorings
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof PoliciesApiTailorings
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof PoliciesApiTailorings
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof PoliciesApiTailorings
     */
    readonly filter?: any
}

/**
 * Request parameters for unassignRule operation in PoliciesApi.
 * @export
 * @interface PoliciesApiUnassignRuleRequest
 */
export interface PoliciesApiUnassignRuleRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiUnassignRule
     */
    readonly policyId: any

    /**
     * 
     * @type {any}
     * @memberof PoliciesApiUnassignRule
     */
    readonly tailoringId: any

    /**
     * UUID or ref_id
     * @type {any}
     * @memberof PoliciesApiUnassignRule
     */
    readonly ruleId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiUnassignRule
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for unassignSystem operation in PoliciesApi.
 * @export
 * @interface PoliciesApiUnassignSystemRequest
 */
export interface PoliciesApiUnassignSystemRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiUnassignSystem
     */
    readonly systemId: any

    /**
     * 
     * @type {any}
     * @memberof PoliciesApiUnassignSystem
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiUnassignSystem
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for updatePolicy operation in PoliciesApi.
 * @export
 * @interface PoliciesApiUpdatePolicyRequest
 */
export interface PoliciesApiUpdatePolicyRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiUpdatePolicy
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiUpdatePolicy
     */
    readonly xRHIDENTITY?: any

    /**
     * 
     * @type {PolicyUpdate}
     * @memberof PoliciesApiUpdatePolicy
     */
    readonly policyUpdate?: PolicyUpdate
}

/**
 * Request parameters for updateTailoring operation in PoliciesApi.
 * @export
 * @interface PoliciesApiUpdateTailoringRequest
 */
export interface PoliciesApiUpdateTailoringRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesApiUpdateTailoring
     */
    readonly policyId: any

    /**
     * UUID or OS minor version number
     * @type {any}
     * @memberof PoliciesApiUpdateTailoring
     */
    readonly tailoringId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiUpdateTailoring
     */
    readonly xRHIDENTITY?: any

    /**
     * 
     * @type {Tailoring}
     * @memberof PoliciesApiUpdateTailoring
     */
    readonly tailoring?: Tailoring
}

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * Assigns a Rule to a Tailoring
     * @summary Assign a Rule to a Tailoring
     * @param {PoliciesApiAssignRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public assignRule(requestParameters: PoliciesApiAssignRuleRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).assignRule(requestParameters.policyId, requestParameters.tailoringId, requestParameters.ruleId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This feature is exclusively used by the frontend
     * @summary Bulk assign Rules to a Tailoring
     * @param {PoliciesApiAssignRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public assignRules(requestParameters: PoliciesApiAssignRulesRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).assignRules(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, requestParameters.assignRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assigns a System to a Policy
     * @summary Assign a System to a Policy
     * @param {PoliciesApiAssignSystemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public assignSystem(requestParameters: PoliciesApiAssignSystemRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).assignSystem(requestParameters.systemId, requestParameters.policyId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This feature is exclusively used by the frontend
     * @summary Bulk assign Systems to a Policy
     * @param {PoliciesApiAssignSystemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public assignSystems(requestParameters: PoliciesApiAssignSystemsRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).assignSystems(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.assignRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Policy with the provided attributes
     * @summary Create a Policy
     * @param {PoliciesApiCreatePolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicy(requestParameters: PoliciesApiCreatePolicyRequest = {}, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicy(requestParameters.xRHIDENTITY, requestParameters.policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Policy
     * @summary Delete a Policy
     * @param {PoliciesApiDeletePolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deletePolicy(requestParameters: PoliciesApiDeletePolicyRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deletePolicy(requestParameters.policyId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Policies
     * @summary Request Policies
     * @param {PoliciesApiPoliciesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policies(requestParameters: PoliciesApiPoliciesRequest = {}, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policies(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Policy
     * @summary Request a Policy
     * @param {PoliciesApiPolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policy(requestParameters: PoliciesApiPolicyRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policy(requestParameters.policyId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Systems assigned to a Policy
     * @summary Request Systems assigned to a Policy
     * @param {PoliciesApiPolicySystemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policySystems(requestParameters: PoliciesApiPolicySystemsRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policySystems(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Tailoring
     * @summary Request a Tailoring
     * @param {PoliciesApiTailoringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public tailoring(requestParameters: PoliciesApiTailoringRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).tailoring(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Tailoring File
     * @summary Request a Tailoring file
     * @param {PoliciesApiTailoringFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public tailoringFile(requestParameters: PoliciesApiTailoringFileRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).tailoringFile(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Rules assigned to a Tailoring
     * @summary Request Rules assigned to a Tailoring
     * @param {PoliciesApiTailoringRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public tailoringRules(requestParameters: PoliciesApiTailoringRulesRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).tailoringRules(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Tailorings
     * @summary Request Tailorings
     * @param {PoliciesApiTailoringsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public tailorings(requestParameters: PoliciesApiTailoringsRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).tailorings(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unassigns a Rule from a Tailoring
     * @summary Unassign a Rule from a Tailoring
     * @param {PoliciesApiUnassignRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public unassignRule(requestParameters: PoliciesApiUnassignRuleRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).unassignRule(requestParameters.policyId, requestParameters.tailoringId, requestParameters.ruleId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unassigns a System from a Policy
     * @summary Unassign a System from a Policy
     * @param {PoliciesApiUnassignSystemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public unassignSystem(requestParameters: PoliciesApiUnassignSystemRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).unassignSystem(requestParameters.systemId, requestParameters.policyId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Policy with the provided attributes
     * @summary Update a Policy
     * @param {PoliciesApiUpdatePolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updatePolicy(requestParameters: PoliciesApiUpdatePolicyRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updatePolicy(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.policyUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Tailoring with the provided value_overrides
     * @summary Update a Tailoring
     * @param {PoliciesApiUpdateTailoringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updateTailoring(requestParameters: PoliciesApiUpdateTailoringRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updateTailoring(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, requestParameters.tailoring, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Report
         * @summary Request a Report
         * @param {any} reportId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report: async (reportId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('report', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Systems assigned to a Report
         * @summary Request Systems assigned to a Report
         * @param {any} reportId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSystems: async (reportId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('reportSystems', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}/systems`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Reports
         * @summary Request Reports
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Reports are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;with_reported_systems&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reports: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Report
         * @summary Request a Report
         * @param {any} reportId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async report(reportId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.report(reportId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Systems assigned to a Report
         * @summary Request Systems assigned to a Report
         * @param {any} reportId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportSystems(reportId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportSystems(reportId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Reports
         * @summary Request Reports
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Reports are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;with_reported_systems&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reports(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reports200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reports(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * Returns a Report
         * @summary Request a Report
         * @param {ReportsApiReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report(requestParameters: ReportsApiReportRequest, options?: AxiosRequestConfig): AxiosPromise<Report200Response> {
            return localVarFp.report(requestParameters.reportId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Systems assigned to a Report
         * @summary Request Systems assigned to a Report
         * @param {ReportsApiReportSystemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSystems(requestParameters: ReportsApiReportSystemsRequest, options?: AxiosRequestConfig): AxiosPromise<Systems200Response> {
            return localVarFp.reportSystems(requestParameters.reportId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Reports
         * @summary Request Reports
         * @param {ReportsApiReportsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reports(requestParameters: ReportsApiReportsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Reports200Response> {
            return localVarFp.reports(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for report operation in ReportsApi.
 * @export
 * @interface ReportsApiReportRequest
 */
export interface ReportsApiReportRequest {
    /**
     * 
     * @type {any}
     * @memberof ReportsApiReport
     */
    readonly reportId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ReportsApiReport
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for reportSystems operation in ReportsApi.
 * @export
 * @interface ReportsApiReportSystemsRequest
 */
export interface ReportsApiReportSystemsRequest {
    /**
     * 
     * @type {any}
     * @memberof ReportsApiReportSystems
     */
    readonly reportId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ReportsApiReportSystems
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ReportsApiReportSystems
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ReportsApiReportSystems
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ReportsApiReportSystems
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ReportsApiReportSystems
     */
    readonly filter?: any
}

/**
 * Request parameters for reports operation in ReportsApi.
 * @export
 * @interface ReportsApiReportsRequest
 */
export interface ReportsApiReportsRequest {
    /**
     * For internal use only
     * @type {any}
     * @memberof ReportsApiReports
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ReportsApiReports
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ReportsApiReports
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ReportsApiReports
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Reports are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;with_reported_systems&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ReportsApiReports
     */
    readonly filter?: any
}

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * Returns a Report
     * @summary Request a Report
     * @param {ReportsApiReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public report(requestParameters: ReportsApiReportRequest, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).report(requestParameters.reportId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Systems assigned to a Report
     * @summary Request Systems assigned to a Report
     * @param {ReportsApiReportSystemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportSystems(requestParameters: ReportsApiReportSystemsRequest, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportSystems(requestParameters.reportId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Reports
     * @summary Request Reports
     * @param {ReportsApiReportsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reports(requestParameters: ReportsApiReportsRequest = {}, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reports(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a System under a Report
         * @summary Request a System
         * @param {any} systemId 
         * @param {any} reportId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSystem: async (systemId: any, reportId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('reportSystem', 'systemId', systemId)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('reportSystem', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}/systems/{system_id}`
                .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)))
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a System
         * @summary Request a System
         * @param {any} systemId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        system: async (systemId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('system', 'systemId', systemId)
            const localVarPath = `/systems/{system_id}`
                .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Systems
         * @summary Request Systems
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systems: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Policies under a System
         * @summary Request Policies assigned to a System
         * @param {any} systemId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemsPolicies: async (systemId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('systemsPolicies', 'systemId', systemId)
            const localVarPath = `/systems/{system_id}/policies`
                .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a System under a Report
         * @summary Request a System
         * @param {any} systemId 
         * @param {any} reportId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportSystem(systemId: any, reportId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportSystem(systemId, reportId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a System
         * @summary Request a System
         * @param {any} systemId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async system(systemId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.system(systemId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Systems
         * @summary Request Systems
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systems(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systems(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Policies under a System
         * @summary Request Policies assigned to a System
         * @param {any} systemId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemsPolicies(systemId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemsPolicies(systemId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemsApiFp(configuration)
    return {
        /**
         * Returns a System under a Report
         * @summary Request a System
         * @param {SystemsApiReportSystemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSystem(requestParameters: SystemsApiReportSystemRequest, options?: AxiosRequestConfig): AxiosPromise<System200Response> {
            return localVarFp.reportSystem(requestParameters.systemId, requestParameters.reportId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a System
         * @summary Request a System
         * @param {SystemsApiSystemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        system(requestParameters: SystemsApiSystemRequest, options?: AxiosRequestConfig): AxiosPromise<System200Response> {
            return localVarFp.system(requestParameters.systemId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Systems
         * @summary Request Systems
         * @param {SystemsApiSystemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systems(requestParameters: SystemsApiSystemsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Systems200Response> {
            return localVarFp.systems(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Policies under a System
         * @summary Request Policies assigned to a System
         * @param {SystemsApiSystemsPoliciesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemsPolicies(requestParameters: SystemsApiSystemsPoliciesRequest, options?: AxiosRequestConfig): AxiosPromise<Policies200Response> {
            return localVarFp.systemsPolicies(requestParameters.systemId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for reportSystem operation in SystemsApi.
 * @export
 * @interface SystemsApiReportSystemRequest
 */
export interface SystemsApiReportSystemRequest {
    /**
     * 
     * @type {any}
     * @memberof SystemsApiReportSystem
     */
    readonly systemId: any

    /**
     * 
     * @type {any}
     * @memberof SystemsApiReportSystem
     */
    readonly reportId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof SystemsApiReportSystem
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for system operation in SystemsApi.
 * @export
 * @interface SystemsApiSystemRequest
 */
export interface SystemsApiSystemRequest {
    /**
     * 
     * @type {any}
     * @memberof SystemsApiSystem
     */
    readonly systemId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof SystemsApiSystem
     */
    readonly xRHIDENTITY?: any
}

/**
 * Request parameters for systems operation in SystemsApi.
 * @export
 * @interface SystemsApiSystemsRequest
 */
export interface SystemsApiSystemsRequest {
    /**
     * For internal use only
     * @type {any}
     * @memberof SystemsApiSystems
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof SystemsApiSystems
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof SystemsApiSystems
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof SystemsApiSystems
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof SystemsApiSystems
     */
    readonly filter?: any
}

/**
 * Request parameters for systemsPolicies operation in SystemsApi.
 * @export
 * @interface SystemsApiSystemsPoliciesRequest
 */
export interface SystemsApiSystemsPoliciesRequest {
    /**
     * 
     * @type {any}
     * @memberof SystemsApiSystemsPolicies
     */
    readonly systemId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof SystemsApiSystemsPolicies
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof SystemsApiSystemsPolicies
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof SystemsApiSystemsPolicies
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof SystemsApiSystemsPolicies
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof SystemsApiSystemsPolicies
     */
    readonly filter?: any
}

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI {
    /**
     * Returns a System under a Report
     * @summary Request a System
     * @param {SystemsApiReportSystemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public reportSystem(requestParameters: SystemsApiReportSystemRequest, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).reportSystem(requestParameters.systemId, requestParameters.reportId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a System
     * @summary Request a System
     * @param {SystemsApiSystemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public system(requestParameters: SystemsApiSystemRequest, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).system(requestParameters.systemId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Systems
     * @summary Request Systems
     * @param {SystemsApiSystemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public systems(requestParameters: SystemsApiSystemsRequest = {}, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).systems(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Policies under a System
     * @summary Request Policies assigned to a System
     * @param {SystemsApiSystemsPoliciesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public systemsPolicies(requestParameters: SystemsApiSystemsPoliciesRequest, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).systemsPolicies(requestParameters.systemId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


